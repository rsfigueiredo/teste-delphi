unit uFrmCalcSimples;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Buttons;

type
  TfrmCalcSimples = class(TForm)
    edtValor: TEdit;
    lbDisplayCalc: TLabel;
    sbtSoma: TSpeedButton;
    Label1: TLabel;
    sbtSubtrac: TSpeedButton;
    sbtMultiplic: TSpeedButton;
    sbtDivsao: TSpeedButton;
    sbtExec: TSpeedButton;
    Label2: TLabel;
    lbInfo: TLabel;
    lbUltExec: TLabel;
    procedure edtValorKeyPress(Sender: TObject; var Key: Char);
    procedure edtValorChange(Sender: TObject);
  protected
    sValOld, sUltDigito, sComandoOld : String;
    bZeraDisplay, bAtUltDigt, bZeraCalc : Boolean;
  private
    procedure execRotina(sComando: String);
    Function AnalizaComando(sKey: Char): Char;
    { Private declarations }
  public
    { Public declarations }
  end;

var
  frmCalcSimples: TfrmCalcSimples;

implementation

{$R *.dfm}

procedure TfrmCalcSimples.edtValorChange(Sender: TObject);
begin
  if not trim(TEdit(Sender).Text).IsEmpty and bAtUltDigt and not bZeraDisplay then
  begin
    sUltDigito := TEdit(Sender).Text;
    lbUltExec.Caption := (sValOld+sComandoOld+sUltDigito);
  end;
end;

procedure TfrmCalcSimples.edtValorKeyPress(Sender: TObject; var Key: Char);
begin
  Key := AnalizaComando(Key);
end;

Function TfrmCalcSimples.AnalizaComando(sKey : Char) : Char;
var
  sComando : String;
begin
  sComando := '';
  // Para o campo só aceitar números
  if not CharInSet(sKey, ['0' .. '9', '+', '-', '*', '/', #$D]) then
    sKey := #0
  else
  begin
    if CharInSet(sKey, ['+', '-', '*', '/', #$D]) then
    begin
      bAtUltDigt := False;
      if CharInSet(sKey, [#$D]) then
        sComando := '='
      else
      begin
        sComando := string(sKey);
      end;

      bZeraCalc := sComando.Contains('=');

      execRotina(sComando);
//      edtValor.Text := EmptyStr;
      sKey := #0;
    end
    else
    begin
      bAtUltDigt := True;
      if bZeraDisplay then
      begin
//        lbUltExec.Caption := (edtValor.Text+sComandoOld);
        lbUltExec.Caption := (sValOld+sComandoOld+sUltDigito);
  //      sUltDigito := String(Key);
        edtValor.Text := EmptyStr;
        bZeraDisplay := False;
      end;
    end;
  end;
  Result := Char(sKey);
end;

procedure TfrmCalcSimples.execRotina(sComando : String);
var
  bExecCalc : Boolean;
begin
  if Trim(sComandoOld).IsEmpty then
  begin
    sComandoOld := sComando;
    sValOld := (edtValor.Text);
    lbUltExec.Caption := (edtValor.Text);
    sUltDigito   := edtValor.Text;
    bZeraDisplay := True;
  end
  else
  begin
    if Trim(edtValor.Text).IsEmpty and sComando.Contains('=') and sUltDigito.IsEmpty then
      sUltDigito := sValOld;
    if sUltDigito.IsEmpty then
      exit;

    bExecCalc := not bZeraDisplay or sComando.Contains('=');

    if (sComandoOld = '*') and bExecCalc then
      edtValor.Text :=  FormatFloat('#,,0.#####',(StrToFloat(sValOld) * StrToFloat(sUltDigito)));
    if (sComandoOld = '/') and bExecCalc then
      edtValor.Text := FormatFloat('#,,0.#####', (StrToFloat(sValOld) / StrToFloat(sUltDigito)));
    if (sComandoOld = '+') and bExecCalc  then
      edtValor.Text :=  FormatFloat('#,,0.#####',(StrToFloat(sValOld) + StrToFloat(sUltDigito)));
    if (sComandoOld = '-') and bExecCalc  then
      edtValor.Text :=  FormatFloat('#,,0.#####',(StrToFloat(sValOld) - StrToFloat(sUltDigito)));

    if not sComando.Contains('=') then
      sComandoOld := sComando;

    if sComando.Contains('=') then
      lbUltExec.Caption := (sValOld+sComandoOld+sUltDigito+'=')
    else
      lbUltExec.Caption := (edtValor.Text+sComandoOld);

    if not Trim(edtValor.Text).IsEmpty then
    begin
      sValOld := (edtValor.Text);
      sValOld := StringReplace(sValOld, '.', '', [rfReplaceAll]);
    end;
    bZeraDisplay := True;
  end;

end;

end.
